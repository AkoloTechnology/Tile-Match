<!DOCTYPE html>
<html>
<head>
<style>
body{margin:0;}

#maindiv {
	margin: auto;
	position: relative;
	width: 800px;
	height: 800px;
	user-select: none;
	overflow:hidden;
}

#maindiv > div {
	position: absolute;
	width: 90px;
	height: 90px;
	user-select: none;
}

#titletext {
	margin:40px;
	text-align: center;
	font-size: 75px;
	line-height: 0;
	user-select: none;
	font-family: 'Brush Script MT', cursive;
}
#scoretext {
	text-align: center;
	line-height: 0;
	font-size: 25px;
	user-select: none;
	font-family: Arial, sans-serif;
}
.points {
	position: absolute;
	text-align: center;
	line-height: 0;
	font-size: 100px;
	user-select: none;
	color: white;
	font-family: 'Brush Script MT', cursive;
	text-shadow: 0 0 8px #000000;
	transform: translate(-50%, -50%);
	white-space: nowrap;
}

</style>
</head>
<body>

<p id="titletext">Tile Match</p>
<p id="scoretext">00000</p> 
<div id="maindiv"></div>
<script>
var tiletypes = ["red","blue","green","yellow","lightseagreen","orange","cyan","moccasin","darkblue","darkred",
				"lightblue","lightred","lightgreen","darkviolet","indigo"];

class Tile {
	constructor(id) {
		this.div = "";
		this.column = 0;
		this.row = 0;
		this.type = "black";
		this.id = id;
		this.dead = false;
	}
	settype(type) {
		this.type = type;
	}
	randomtype(typerange) {
		let random = Math.floor(Math.random() * typerange);
		this.type = tiletypes[random];
	}
	setrow(row) {
		this.row = row;
	}
	setdivrow(oldrow, newrow) {
		if (oldrow == newrow)
			return;
		var id = null;
		var elem = this.div;
		var row_start = oldrow;
		var ticker = 0;
		var end_ticker = (newrow - oldrow) * 8;
		clearInterval(id);
		id = setInterval(frame, 10);
		game.tilesfalling += 1;
		function frame() {
			if (ticker == end_ticker) {
				clearInterval(id);
				elem.style.top = (newrow*100+5) + "px";
				game.tilesfalling -= 1;
				if (game.tilesfalling == 0)
					game.checkmatches()
			} else {
				ticker++;
				let newloc = (ticker/8) + row_start;
				elem.style.top = (newloc*100+5) + "px";
			}
		}
	}
	setcolumn(column) {
		this.column = column;
	}
	updaterow(amount) {
		let oldrow = this.row;
		this.row += amount;
		this.setdivrow(oldrow, this.row);
	}
	creatediv() {	
		this.div = document.createElement("div");
		this.div.style.backgroundColor = this.type;
		this.div.classList.add("tile");
		this.div.id = "tile" + this.id;
		this.div.style.top = (-1*100+5) + "px";
		this.div.style.left = (this.column*100+5) + "px";
		this.div.onclick = () => this.onclick();
		this.div.onmouseover = () => this.onmouseover();
		this.div.onmouseleave = () => this.onmouseleave();
		return this.div;
	}
	deletediv() {
		this.dead = true;
		this.div.style.outline = "";
		var id = null;
		var elem = this.div;
		var ticker = 0;
		var row = this.row;
		var col = this.column;
		clearInterval(id);
		id = setInterval(frame, 10);
		elem.style.zIndex = 1000;
		function frame() {
			if (ticker == 10) {
				clearInterval(id);
				elem.remove();
			} else {
				ticker++;
				elem.style.top = (row*100+5-ticker*2) + "px";
				elem.style.left = (col*100+5-ticker*2) + "px";
				elem.style.width = (90+ticker*4) + "px";
				elem.style.height = (90+ticker*4) + "px";
				elem.style.opacity = 1-(ticker/10);
			}
		}
	}
	onclick() {
		if (game.tilesfalling)
			return;			
		if (game.selectedtile == null)
		{
			game.selectedtile = this;
			this.div.style.boxShadow  = "0 0 50px black";
			this.div.style.outline = "";
			this.div.style.zIndex = 1000;
		} else if (game.selectedtile == this) {
			game.selectedtile = null;
			this.div.style.boxShadow  = "";
			this.div.style.outline = "";
			this.div.style.zIndex = "auto";
		} else {
			if (game.selectedtile.row == this.row && (game.selectedtile.column == this.column - 1 || game.selectedtile.column == this.column + 1)) {
				game.selectedtile.div.style.boxShadow = "";
				this.div.style.boxShadow = "";
				var id = null;
				var tile1 = this;
				var tile2 = game.selectedtile;
				var elem1 = this.div;
				var elem2 = game.selectedtile.div;
				var elem1_column = this.column;
				var elem2_column = game.selectedtile.column;
				var direction = elem1_column - elem2_column;
				var ticker = 0;
				clearInterval(id);
				id = setInterval(frame, 10);
				game.tilesfalling += 1;
				game.selectedtile = null;
				function frame() {
					if (ticker == 10) {
						[tile1.type, tile2.type] = [tile2.type, tile1.type];
						let validmove = false;
						if(game.validmove(tile1.column, tile1.row, tile1.type))
							validmove = true;
						if(game.validmove(tile2.column, tile2.row, tile2.type))
							validmove = true;
						if (validmove)
						{
							clearInterval(id);
							elem1.style.left = (elem1_column*100+5) + "px";
							elem2.style.left = (elem2_column*100+5) + "px";
							game.tilesfalling -= 1;
							elem1.style.backgroundColor = tile1.type;
							elem2.style.backgroundColor = tile2.type;
							elem1.style.zIndex = "auto";
							elem2.style.zIndex = "auto";
							if (game.tilesfalling == 0)
								game.checkmatches();
						} else {
							[tile1.type, tile2.type] = [tile2.type, tile1.type];
							ticker = 0;
							clearInterval(id);
							id = setInterval(revertframe, 10);
							function revertframe() {
								if (ticker == 10) {
									clearInterval(id);
									game.tilesfalling -= 1;
									elem1.style.left = (elem1_column*100+5) + "px";
									elem2.style.left = (elem2_column*100+5) + "px";
									elem1.style.zIndex = "auto";
									elem2.style.zIndex = "auto";
								} else {
									ticker++;
									let elem2_loc = (ticker/10)*(-direction) + elem1_column;
									let elem1_loc = (ticker/10)*(direction) + elem2_column;
									elem1.style.left = (elem1_loc*100+5) + "px";
									elem2.style.left = (elem2_loc*100+5) + "px";
								}
							}									
						}						
					} else {
						ticker++;
						let elem1_loc = (ticker/10)*(-direction) + elem1_column;
						let elem2_loc = (ticker/10)*(direction) + elem2_column;
						elem1.style.left = (elem1_loc*100+5) + "px";
						elem2.style.left = (elem2_loc*100+5) + "px";
					}
				}
			} else if (game.selectedtile.column == this.column && (game.selectedtile.row == this.row - 1 || game.selectedtile.row == this.row + 1)) {
				game.selectedtile.div.style.boxShadow = "";
				this.div.style.boxShadow = "";
				game.selectedtile.div.style.outline = "";
				var id = null;
				var tile1 = this;
				var tile2 = game.selectedtile;
				var elem1 = this.div;
				var elem2 = game.selectedtile.div;
				var elem1_row = this.row;
				var elem2_row = game.selectedtile.row;
				var direction = elem1_row - elem2_row;
				var ticker = 0;
				clearInterval(id);
				id = setInterval(frame, 10);
				game.tilesfalling += 1;
							game.selectedtile = null;
				function frame() {
					if (ticker == 10) {
						[tile1.type, tile2.type] = [tile2.type, tile1.type];
						let validmove = false;
						if(game.validmove(tile1.column, tile1.row, tile1.type))
							validmove = true;
						if(game.validmove(tile2.column, tile2.row, tile2.type))
							validmove = true;
						if (validmove)
						{
							clearInterval(id);
							elem1.style.top = (elem1_row*100+5) + "px";
							elem2.style.top = (elem2_row*100+5) + "px";
							game.tilesfalling -= 1;
							elem1.style.backgroundColor = tile1.type;
							elem2.style.backgroundColor = tile2.type;
							if (game.tilesfalling == 0)
								game.checkmatches();
						} else {
							[tile1.type, tile2.type] = [tile2.type, tile1.type];
							ticker = 0;
							clearInterval(id);
							id = setInterval(revertframe, 10);
							function revertframe() {
								if (ticker == 10) {
									clearInterval(id);
									game.tilesfalling -= 1;
									elem1.style.top = (elem1_row*100+5) + "px";
									elem2.style.top = (elem2_row*100+5) + "px";
									elem1.style.zIndex = "auto";
									elem2.style.zIndex = "auto";
								} else {
									ticker++;
									let elem2_loc = (ticker/10)*(-direction) + elem1_row;
									let elem1_loc = (ticker/10)*(direction) + elem2_row;
									elem1.style.top = (elem1_loc*100+5) + "px";
									elem2.style.top = (elem2_loc*100+5) + "px";
								}
							}									
						}
					} else {
						ticker++;
						let elem1_loc = (ticker/10)*(-direction) + elem1_row;
						let elem2_loc = (ticker/10)*(direction) + elem2_row;
						elem1.style.top = (elem1_loc*100+5) + "px";
						elem2.style.top = (elem2_loc*100+5) + "px";
					}
				}
			}
		}
		
	}
	onmouseover() {
		if (game.pause)
			return;
		if (game.selectedtile != this)
			this.div.style.outline = "";
	}
	onmouseleave() {
		if(game.pause)
			return;
		if (game.selectedtile != this)
			this.div.style.outline = "";
	}
}

class GameManager 
{
	constructor() {
		this.score = 0;
		this.currentid = 0;
		this.tilearray = new Array(8);
		for(let i = 0; i < 8; i++)
			this.tilearray[i] = new Array(8);
		this.level = 5;
		this.maindiv = document.getElementById("maindiv");
		this.combdiv = document.createElement("div");
		this.combdiv.classList.add("points");
		this.combdiv.style.left = 250 + "px";
		this.combdiv.style.top = 400 + "px";
		this.maindiv.appendChild(this.combdiv);
		this.combdiv.style.zIndex = 1500;	
		this.combdivid = null;
		this.pause = false;
		this.tilesfalling = 0;
		this.selectedtile = null;
		this.currentcombo = 0;
	}
	updatecolumn(column) {
		let col = this.tilearray[column];
		
		// remove all tiles that are destroyed
		for (let row = 0; row < 8; row++) {
			if (col[row] == undefined)
				continue;
			if (col[row].dead) {
				col[row].deletediv();
				col[row] = null;
			}
		}
		
		// move down tiles
		let moves = 0;
		for (let row = 7; row >= 0; row--) {
			if (col[row] == undefined) {
				moves++;
			} else if (moves > 0) {
				col[row].updaterow(moves);
				col[row+moves] = col[row];
				col[row] = null;
			}
		}
		
		// add new tiles
		let count = 0;
		for (let row = 7; row >= 0; row--) {
			if (col[row] == undefined) {
				count++;
				let newtile = new Tile(this.currentid);
				this.currentid += 1;
				newtile.setcolumn(column);
				newtile.setrow(row);
				newtile.randomtype(this.level);
				this.maindiv.appendChild(newtile.creatediv());
				newtile.setdivrow(-count,row);
				col[row] = newtile;
			}
		}
	}
	updatescore() {
		let scoretext = String(this.score).padStart(5,'0');
		document.getElementById("scoretext").innerHTML = scoretext;
		if (this.score > this.level * 1000 - 4000)
			this.level++;
	}
	checkline(line, axis) {
		let anymatches = 0;
		let column = 0, row = 0;
		for (let i = 0; i < 6; i++) {
			if (axis)
				{column = i; row = line;}
			else 
				{row = i; column = line;}
			let tiles = [this.tilearray[column][row]];
			let type = tiles[0].type;
			for (i++; i < 8; i++) {
				if (axis)
					{column = i; row = line;}
				else 
					{row = i; column = line;}
				if (this.tilearray[column][row].type == type)
					tiles.push(this.tilearray[column][row]);
				else
					break;
			}
			i--;
			if (tiles.length <= 2)
				continue;
			if (tiles.length == 3)
				this.pointsbubble(3, 40, tiles[1]);
			if (tiles.length == 4)
				this.pointsbubble(10, 60, tiles[1]);
			if (tiles.length >= 5)
				this.pointsbubble(50, 80, tiles[2]);
			for(const tile of tiles)
				if(tile.dead)
					this.pointsbubble(100, 100, tile);
				else
					tile.dead = true;
			anymatches += 1;
		}		
		return anymatches;
	}
	pointsbubble(amount,fontsize,tile) {
		this.score += amount;
		let mainrect = this.maindiv.getBoundingClientRect();
		let x = tile.column * 100 + 50 + mainrect.left;
		let y = tile.row * 100 + 75 + mainrect.top;
		let newdiv = document.createElement("div");
		newdiv.innerHTML = amount;
		newdiv.style.top = y + "px";
		newdiv.style.left = x + "px";
		newdiv.style.fontSize  = fontsize + "px";;
		var ticker = 0;
		var id = null;
		clearInterval(id);
		id = setInterval(frame, 1);
		newdiv.classList.add("points");
		//game.maindiv.appendChild(newdiv);
		document.body.appendChild(newdiv);
		newdiv.style.zIndex = 1000;	
		function frame() {
			if (ticker == 100) {
				clearInterval(id);
				newdiv.remove();
			} else {
				ticker++;
				newdiv.style.top = (y - (ticker/2)) + "px";
			}		
		}
	}
	combo() {
		this.score += this.currentcombo * 10;
		this.combdiv.innerHTML = "COMBO x" + this.currentcombo;
		var currentcombo = this.currentcombo;
		var ticker = 0;
		clearInterval(game.combdivid);
		game.combdivid = setInterval(frame, 1);
		game.combdiv.hidden = false;
		function frame() {	
			if (ticker == 350) {
				clearInterval(game.combdivid);
				game.combdiv.hidden = true;
			} else {
				ticker++;
				game.combdiv.style.opacity = 1 - (ticker/350);
			}		
		}
	}
	checkmatches() {
		let anymatches = 0;
		for (let i = 0; i < 8; i++) {
			anymatches += this.checkline(i, true);
			anymatches += this.checkline(i, false);
		}
		if (anymatches)
		{
			this.currentcombo += anymatches;
			if (this.currentcombo > 1)
				this.combo();
			this.updatescore();
			this.updategrid();
		}
		else
			this.currentcombo = 0;
		this.updatescore();
	}
	validmove(column, row, type) {
		if (1 < row)
			if (this.tilearray[column][row - 1].type == type && this.tilearray[column][row - 2].type == type)
				return true;
		if (0 < row && row < 7)
			if (this.tilearray[column][row - 1].type == type && this.tilearray[column][row + 1].type == type)
				return true;
		if (row < 6)
			if (this.tilearray[column][row + 1].type == type && this.tilearray[column][row + 2].type == type)
				return true;
		if (1 < column)
			if (this.tilearray[column - 1][row].type == type && this.tilearray[column - 2][row].type == type)
				return true;
		if (0 < column && column < 7)
			if (this.tilearray[column - 1][row].type == type && this.tilearray[column + 1][row].type == type)
				return true;
		if (column < 6)
			if (this.tilearray[column + 1][row].type == type && this.tilearray[column + 2][row].type == type)
				return true;
		return false;
	}
	gettile(div) {
		let tileid = Number(div.id.substr(4));
		for (const tile of this.tilearray) {
			if(tile.id == tileid)
				return tile;
		}
		return null;			
	}
	updategrid() {
		for (let i = 0; i < 8; i++)
			this.updatecolumn(i);
	}
	newgame() {
		for (let column = 0; column < 8; column++)
			setTimeout(()=> {
				// add new tiles
				let col = game.tilearray[column];
				let count = 0;
				for (let row = 7; row >= 0; row--)
					if (col[row] == undefined) {
						count++;
						let newtile = new Tile(game.currentid);
						game.currentid += 1;
						newtile.setcolumn(column);
						newtile.setrow(row);
						newtile.randomtype(game.level);
						game.maindiv.appendChild(newtile.creatediv());
						newtile.setdivrow(-count,row);
						col[row] = newtile;
					}
				} ,
				Math.floor(Math.random() * 20)*20);
	}
}

var game = new GameManager();
game.newgame();
</script>
</body>
</html>
